#pragma once
#ifndef ALGORITHM_HPP
#define ALGORITHM_HPP

#include "matrix.hpp"
#include "condition.hpp" // delete
#include <algorithm>

#ifdef CXX_BUILDER_CXX17
# include <boost/optional.hpp>
# define TVD_NULLOPT boost::none
# define TVD_OPTIONAL(type) boost::optional<type>
#else
# include <optional>
# define TVD_NULLOPT std::nullopt
# define TVD_OPTIONAL(type) std::optional<type>
#endif

namespace tvd {

template<
	class _MatrixTy,
	class _VectorTy,
	class _ConditionTy>
	bool insert_if( _MatrixTy & m, _VectorTy const& v, _ConditionTy const& c) noexcept
	{
	  for( size_t i(0); i < std::size(m); i++ )
		  if( !c(m[i]) ) return false;
	  m.push_back( v );
	  return true;
	}

template<
	typename _RTMatrixTy,
	typename _Ty>
	TVD_OPTIONAL( _RTMatrixTy )
	lee_neumann( _RTMatrixTy const& map,
				 size_t x_from, size_t y_from,
				 size_t x_to,   size_t y_to,
				 _Ty blank                     )
	{
	  if( map.size() <= y_from || map.csize() <= x_from || map.size() <= y_to || map.csize() <= x_to ) {
		  throw TVD_EXCEPTION("<tvd::lee_neumann> : out of range");
	  }
	  if( map[y_from][x_from] != blank || map[y_to][x_to] != blank ) {
		  return TVD_NULLOPT;
	  }
	  _RTMatrixTy     way  = {{ y_from, x_from, 0 }};
	  const int       dx[] = { 1, 0, -1,  0 };
	  const int       dy[] = { 0, 1,  0, -1 };
	  bool            stop;

	  auto wave_propagation = [&map,  &blank,
							   &way,  &stop,
							   &dx,   &dy,
							   &x_to, &y_to  ]( const auto y, const auto x, const auto & d ) -> int
	  {
		for( size_t i(0); i < 4; i++ )
		{
			int iy = y + dy[i], ix = x + dx[i];
			if ( (map.size() > iy || map.csize() > ix) &&
				  iy          >= 0                     &&
				  ix          >= 0                     &&
				  map[iy][ix] == blank                    )
			{
				if( insert_if( way, { iy, ix, d + 1 },
					[&ix, &iy]( auto const& v ) {
					  return !(v[0] == iy && v[1] == ix);
					}) )
				{
					if( iy == y_to && ix == x_to) {
						return std::size(way) - 1;
					}
					stop = false;
				}
			}
		}
		return 0;
	  };

	  int y_end(0);
	  size_t d(0);

	  do {
		stop = true;
		for( size_t i(0); i < std::size(way); i++ )
		{
			if( way[i][2] == d ) {
				y_end = wave_propagation( way[i][0], way[i][1], d );
			}
			if( y_end ) {
				break;
			}
		}
		d++;
	  } while( !stop );

	  if( !y_end ) return TVD_NULLOPT;

	  auto neighbour = [&dx, &dy]( auto const& curr_v, auto const& last_v )
	  {
		return ( ( last_v[0] - 1 == curr_v[0]   || last_v[0] + 1 == curr_v[0] ) &&
				 ( last_v[1]     == curr_v[1] ) ||
				 ( last_v[1] - 1 == curr_v[1]   || last_v[1] + 1 == curr_v[1] ) &&
				 ( last_v[0]     == curr_v[0] )                                    );
	  };

	  size_t x( x_to ), y( y_to );
	  decltype( way[0] ) last_v( way[y_end] );
	  d = way[y_end][2] - 1;
	  y_end--;
	  _RTMatrixTy min_w;
	  min_w.push_back( { x_to, y_to, 1 } );

	  while( d > 0 ) {
		auto l = d;
		for( size_t i(y_end); i != 0; i-- )
		{
			if( way[i][2] == d && neighbour(way[i], last_v) ) {
				min_w.push_back( { way[i][1], way[i][0], 1 } );
				last_v = way[i];
				d--;
				break;
			}
		}
		if( l == d ) {
			return TVD_NULLOPT;
		}
	  }

	  min_w.push_back( { x_from, y_from, 1 } );
	  return min_w;
	}
// swap if
template<
    typename _Ty,
    typename _ConditionTy>
    void swap_if( _Ty & l, _Ty & r, _ConditionTy const& condition )
	{
	  if( !condition(l, r) ) return;
	  std::swap(l, r);
	}
// min value in matrix column
template<typename _MatrixTy>
	auto min( _MatrixTy const& m, size_t j_pos ) -> decltype( *m.begin() )
	{
	  if( m.empty() ) {
		  throw TVD_EXCEPTION("<tvd::min> : <matrix> is empty");
	  }
	  auto size = m.csize();
	  if( size <= j_pos ) {
		  throw TVD_EXCEPTION("<tvd::min> : <matrix.csize> <= <j_pos>");
	  }
	  auto first = m.cbegin();
	  auto last = m.cend();
	  first += j_pos;
	  auto min = (*first);
	  for(auto & fst(first); fst < last; fst += size)
	  {
		  if( min > (*fst) ) min = (*fst);
	  }
	  return min;
	}
// max value in matrix column
template<typename _MatrixTy>
	auto max( _MatrixTy const& m, size_t j_pos ) -> decltype( *m.begin() )
	{
	  if( m.empty() ) {
		  throw TVD_EXCEPTION("<tvd::max> : <matrix> is empty");
	  }
	  auto size = m.csize();
	  if( size <= j_pos ) {
		  throw TVD_EXCEPTION("<tvd::max> : <matrix.csize> <= <j_pos>");
	  }
	  auto first = m.cbegin();
	  auto last = m.cend();
	  auto max = (*first);
	  first += j_pos;
	  for(auto & fst(first); fst < last; fst += size)
	  {
		  if( max < (*fst) ) max = (*fst);
	  }
	  return max;
	}
// min & max value in matrix column  *m.bigin()
template<typename _MatrixTy>
	auto minmax( _MatrixTy const& m, size_t j_pos )
	  -> std::pair<decltype( min( m, j_pos ) ), decltype( max( m, j_pos ) )>
	{
	  return { min( m, j_pos ), max( m, j_pos ) };
	}
} // tvd
# undef TVD_NULLOPT
#endif
